/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package pascalanalyser;

import java.awt.Color;
import java.util.Arrays;
import javax.swing.text.DefaultHighlighter;
import javax.swing.text.Highlighter;

/**
 *
 * @author akaleaf
 */
public class PascalAnalyserGUI extends javax.swing.JFrame {
    
    String keywords[];
    String operators[];
    String separators[];
    String variables[] = new String[0];
    String variablesValues[] = new String[0];
    String programEnd = "";
    String failure = "program analysis has ended with failure";
    String success = "program analysis has ended with success";
    
    /**
     * Creates new form PascalAnalyserGUI
     */
    public PascalAnalyserGUI() {
        
        this.keywords = new String[] {
            "program",
            "var",
            "integer",
            "begin",
            "end",
        };
        
        this.separators = new String[] {
            ";",
            ".",
            ",",
            ":",
            "(",
            ")",
        };
        
        this.operators = new String[]{
            "=",
            "+",
            "-",
            "/",
            "*",
        };
        
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        panelMain = new javax.swing.JPanel();
        panelSource = new javax.swing.JPanel();
        panelSourceLabel = new javax.swing.JPanel();
        labelSource = new javax.swing.JLabel();
        panelSourceText = new javax.swing.JPanel();
        jScrollPane4 = new javax.swing.JScrollPane();
        textPaneSource = new javax.swing.JTextPane();
        panelResult = new javax.swing.JPanel();
        panelResultLabel = new javax.swing.JPanel();
        labelResult = new javax.swing.JLabel();
        panelResultTextArea = new javax.swing.JPanel();
        jScrollPane3 = new javax.swing.JScrollPane();
        textAreaResult = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("PascalAnalyser");
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowActivated(java.awt.event.WindowEvent evt) {
                formWindowActivated(evt);
            }
        });

        labelSource.setText("Source:");

        javax.swing.GroupLayout panelSourceLabelLayout = new javax.swing.GroupLayout(panelSourceLabel);
        panelSourceLabel.setLayout(panelSourceLabelLayout);
        panelSourceLabelLayout.setHorizontalGroup(
            panelSourceLabelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelSourceLabelLayout.createSequentialGroup()
                .addGap(112, 112, 112)
                .addComponent(labelSource, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(113, 113, 113))
        );
        panelSourceLabelLayout.setVerticalGroup(
            panelSourceLabelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelSourceLabelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(labelSource)
                .addContainerGap())
        );

        textPaneSource.setText("program ya_na_etom_sobaku_siel;\n\tvar a, b, c : integer;\nvar s : integer;\nbegin\nb = a + 100;\na = 250 / b;\nc = (a + b)*(c-10);\na = 10 * 10;\nb = 1;\nc = (b + 1) + b + ((b + a) + b) + b;\nend.");
        textPaneSource.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                textPaneSourceKeyReleased(evt);
            }
        });
        jScrollPane4.setViewportView(textPaneSource);

        javax.swing.GroupLayout panelSourceTextLayout = new javax.swing.GroupLayout(panelSourceText);
        panelSourceText.setLayout(panelSourceTextLayout);
        panelSourceTextLayout.setHorizontalGroup(
            panelSourceTextLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane4)
        );
        panelSourceTextLayout.setVerticalGroup(
            panelSourceTextLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 326, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout panelSourceLayout = new javax.swing.GroupLayout(panelSource);
        panelSource.setLayout(panelSourceLayout);
        panelSourceLayout.setHorizontalGroup(
            panelSourceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelSourceLayout.createSequentialGroup()
                .addComponent(panelSourceLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
            .addComponent(panelSourceText, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        panelSourceLayout.setVerticalGroup(
            panelSourceLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelSourceLayout.createSequentialGroup()
                .addComponent(panelSourceLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(panelSourceText, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        labelResult.setText("Result:");

        javax.swing.GroupLayout panelResultLabelLayout = new javax.swing.GroupLayout(panelResultLabel);
        panelResultLabel.setLayout(panelResultLabelLayout);
        panelResultLabelLayout.setHorizontalGroup(
            panelResultLabelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelResultLabelLayout.createSequentialGroup()
                .addGap(116, 116, 116)
                .addComponent(labelResult, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(114, 114, 114))
        );
        panelResultLabelLayout.setVerticalGroup(
            panelResultLabelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelResultLabelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(labelResult)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        textAreaResult.setColumns(20);
        textAreaResult.setRows(5);
        jScrollPane3.setViewportView(textAreaResult);

        javax.swing.GroupLayout panelResultTextAreaLayout = new javax.swing.GroupLayout(panelResultTextArea);
        panelResultTextArea.setLayout(panelResultTextAreaLayout);
        panelResultTextAreaLayout.setHorizontalGroup(
            panelResultTextAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 269, Short.MAX_VALUE)
        );
        panelResultTextAreaLayout.setVerticalGroup(
            panelResultTextAreaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane3)
        );

        javax.swing.GroupLayout panelResultLayout = new javax.swing.GroupLayout(panelResult);
        panelResult.setLayout(panelResultLayout);
        panelResultLayout.setHorizontalGroup(
            panelResultLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panelResultLayout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(panelResultTextArea, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addComponent(panelResultLabel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        panelResultLayout.setVerticalGroup(
            panelResultLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelResultLayout.createSequentialGroup()
                .addComponent(panelResultLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(panelResultTextArea, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        javax.swing.GroupLayout panelMainLayout = new javax.swing.GroupLayout(panelMain);
        panelMain.setLayout(panelMainLayout);
        panelMainLayout.setHorizontalGroup(
            panelMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelMainLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(panelSource, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(panelResult, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        panelMainLayout.setVerticalGroup(
            panelMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panelMainLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelMainLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(panelResult, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(panelSource, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(panelMain, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(panelMain, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formWindowActivated(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowActivated
        updateResults();
    }//GEN-LAST:event_formWindowActivated

    private void textPaneSourceKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_textPaneSourceKeyReleased
        updateResults();
    }//GEN-LAST:event_textPaneSourceKeyReleased

    //<editor-fold defaultstate="collapsed" desc="printErros">
    private void printError() {
        textAreaResult.append("asd");
    }
    
    private void printError(String msgError) {
        textAreaResult.append(msgError);
    }
    
    private void printError(String msgError, String cause) {
        textAreaResult.append(msgError + ": " + cause);
    }
    
    private void paintLineToRed(String line, int start) {
        //        line += "\n";
        Highlighter.HighlightPainter redPainter = new DefaultHighlighter.DefaultHighlightPainter(Color.red);
        try {
            textPaneSource.getHighlighter().addHighlight(start, start + line.length(), redPainter);
        } catch (Exception e) {}
    }//</editor-fold>
    
    // Проверка есть ли ";". Необходимость метода под вопросом
    private boolean checkIfThereIsSemicolon(String splittedLine[]) {
        
        // Пройтись по массиву
        for (String string : splittedLine) {
            // Если есть, то вернуть всё хорошо
            if (string.equals(";")) {
                return true;
            }
        }
        
        // Если нету, сказать, что ожидали найти
        tarap("';' expected");
        programEnd = failure;
        return false;
    }
    
    // Обработка ключевых слов
    private void processKeyword(String keyword, String splittedLine[]) {
        // Так какое же у нас ключевое слово?
        switch (keyword) {
            case "program":
                // Обработать как "program"
                if (!processKeywordProgram(splittedLine)) {
                    tarap("invalid syntax");
                    programEnd = failure;
                }
                break;
                
            case "var":
                // Обработать как "var"
                if (!processKeywordVar(splittedLine)) {
                    tarap("invalid syntax");
                    programEnd = failure;
                }
                break;
                
            case "begin":
                // Обработать как "begin"
                if (!processKeywordBegin(splittedLine)) {
                    tarap("invalid syntax");
                    programEnd = failure;
                }
                break;
                
            case "end":
                // Обработать как "end"
                if (!processKeywordEnd(splittedLine)) {
                    tarap("invalid syntax");
                    programEnd = failure;
                }
                break;
                
            default:
                break;
        }
    }
    
    // Обработка ключевого слова - program
    private boolean processKeywordProgram(String splittedLine[]) {
        
        // Проверить, есть ли semicolon
        if (!checkIfThereIsSemicolon(splittedLine)) {
            return false;
        }
        
        // Если элементов в строке более 3
        if (splittedLine.length > 3) {
            // то это неправильно
            programEnd = failure;
            return false;
        }
        
        // Выведем название программы
        tarap("program name: " + splittedLine[1]);
        tarap("");
        
        // Всё хорошо
        return true;
    }
    
    // Обработка ключевого слова - var
    private boolean processKeywordVar(String splittedLine[]) {
        
        // Проверить есть ли semicolon
        if (!checkIfThereIsSemicolon(splittedLine)) {
            // Если нет, вернуться
            return false;
        }
        
        // Двоеточие уже было?
        boolean colon = false;
        // Проходимся по массиву элементов строки
        // sli stands for splittedLineItem
        for (String sli : splittedLine) {
            // Если ещё не было двоеточия
            if (!colon) {
                // Если ключевое слово попалось
                if (isKeyword(sli)) {
                    // Если оно "var"
                    if (sli.equals("var")) {
                        // Пропускаем
                        continue;
                    }
                    // Если не "var", а другое ключевое слово, то говорим, что ошибка
                    tarap("variable expected. got keyword " + sli);
                    programEnd = failure;
                    return false;
                }
                // Если попался сепаратор
                if (isSeparator(sli)) {
                    // Если semicolon
                    if (sli.equals(";")) {
                        // Кончаем цикл
                        break;
                    } else 
                    // Или если двоеточие
                    if (sli.equals(":")) {
                        // Сохраняем информацию о том, что встретилось двоеточие
                        colon = true;
                        // Пропускаем
                        continue;
                    }
                    // Остальные сепараторы пропускаем
                    continue;
                }
                // Если попался оператор
                if (isOperator(sli)) {
                    // Говорим, что ожидали переменную, а не оператор
                    tarap("variable expected. got operator " + sli);
                    programEnd = failure;
                    return false;
                }

                // Добавляем к переменным новую
                if (!addToVariables(sli)) {
                    // Если не добавляется, говорим об ошибке
                    tarap("variable already defined: " + sli);
                    programEnd = failure;
                    return false;
                }
                
                // Говорим, что новая переменная объявлена
                tarap("new variable declared: " + sli);
            } else 
            // Если двоеточие уже было
            {
                // Если попалось ключевое слово
                if (isKeyword(sli)) {
                    // Если ключевое слово - "integer"
                    if (sli.equals("integer")) {
                        // Пропускаем
                        continue;
                    }
                    // Говорим, что ожидали integer, а получали что-то другое
                    tarap("keyword type expected. got keyword " + sli);
                    programEnd = failure;
                    return false;
                }
                // Если попался сепаратор
                if (isSeparator(sli)) {
                    // Если сепаратор semicolon
                    if (sli.equals(";")) {
                        // Кончаем цикл
                        break;
                    }
                    // Говорим, что ожидали integer, а получили какой-то сепаратор
                    tarap("keyword type expected. got separator " + sli);
                    programEnd = failure;
                    return false;
                }
                // Если попался оператор
                if (isOperator(sli)) {
                    // Говорим, что ожидали integer, а получили какой-то оператор
                    tarap("keyword type expected. got operator " + sli);
                    programEnd = failure;
                    return false;
                }
                // Говорим, что ожидали integer или semicolon, а получили чёрт-те что
                tarap("keyword type or ';' expected. got literal " + sli);
                programEnd = failure;
                return false;
            }
        }
        
        // Всё хорошо
        return true;
    }
    
    // Обработка ключевого слова - begin
    private boolean processKeywordBegin(String splittedLine[]) {
        
        // Если в строке больше одного элемента
        if (splittedLine.length > 1) {
            // Всё плохо
            programEnd = failure;
            return false;
        }
        
        // Всё хорошо
        return true;
    }
    
    // Обработка ключевого слова - end
    private boolean processKeywordEnd(String splittedLine[]) {
        
        // Если в строке более 2 элементов
        if (splittedLine.length > 2) {
            // Всё плохо
            programEnd = failure;
            return false;
        }
        
        // Если второй элемент равен "."
        // (Первый - "end")
        if (splittedLine[1].equals(".")) {
            // Вывести сообщение о завершении анализа текста
            tarap("");
            tarap(programEnd);
            return true;
        }
        
        // Всё хорошо
        return true;
    }
    
    // Метод для обработки литералов (?)
    private boolean processLiteral(String literal, String[] splittedLine) {
        // Правда вряд ли ему подходит это навзание.
        // Метод создавался на начальной стадии разработки приложения.
        // Сейчас, вероятно, ему больше подойдёт имя processInitialization.
        
        
        // Видимо на ранней стадии разработки приложения эта проверка была нужна,
        // но сейчас я её закомментирую. 
        // Не буду удалять, мало ли из-за этого что-нибудь сломается и придётся восстанавливать
//        if (!isVariableDeclared(literal)) {
//            tarap("variable not declared " + literal);
//            return false;
//        }
        
        // Если второй элемент - "="
        if (splittedLine[1].equals("=")) {
            // Обработать оператор "=" - начало
            String[] leftExpression = getLeftPart(splittedLine, 1);
            String[] rightExpression = getRightPart(splittedLine, 1);
            
            removeLastSemicolonFromArray(leftExpression);
            removeLastSemicolonFromArray(rightExpression);
            
            processOperatorEquals(leftExpression, rightExpression);
            // Обработать оператор "=" - конец
        } else {
            // Иначе сказать, что ожидался оператор "="
            tarap("'=' operator expected. got '" + splittedLine[1] + "'");
            return false;
        }
        
        return true;
    }
    
    // Обработка операторов
    private int processOperator(String operator, String[] expressionLeft, String[] expressionRight) {
        // Первый операнд
        int firstOperand = getOperandLeft(expressionLeft, expressionRight);
        
        // Второй операнд
        int secondOperand = getOperandRight(expressionLeft, expressionRight);
        
        // Какой же оператор?
        switch (operator) {
            // "="?
            case "=":
                // тогда обработать
                if (!processOperatorEquals(expressionLeft, expressionRight)) {
                    // Если в процессе обработки возникла ошибка, то вывести сообщение об ошибке
                    tarap("invalid syntax");
                    programEnd = failure;
                }
                break;
                
            case "+":
                // Обработка "+"
                return processOperatorPlus(firstOperand, secondOperand);
                
            case "-":
                // Обработка "-"
                return processOperatorMinus(firstOperand, secondOperand);
                
            case "/":
                // Обработка "/"
                return processOperatorDivide(firstOperand, secondOperand);
                
            case "*":
                // Обработка "*"
                return processOperatorMultiply(firstOperand, secondOperand);
                
            default:
                // unreachable statement, по идее
                return 0;
        }
        // unreachable statement, по идее
        return 0;
    }
    
    // Получить левый операнд
    private int getOperandLeft(String[] expressionLeft, String[] expressionRight) {
        // Последний элемент выражения слева
        String lastItem = expressionLeft[expressionLeft.length - 1];
        
        // Первый элемент может быть числом?
        if (isNumeric(lastItem)) {
            // Возвратим число
            return Integer.parseInt(lastItem);
        } else 
        // Ну или если это переменная
        if (isVariableDeclared(lastItem)) {
            // Вернуть значение переменной
            return Integer.parseInt(getVariableValue(lastItem));
        } else 
        // Ну или это скобка?
        if (lastItem.equals(")")) {
            // Тогда начать обработку выражения за скобкой
            expressionLeft[expressionLeft.length - 1] = "";
            expressionLeft = removeEmptyValuesFromTheArray(expressionLeft);
            return processSeparatorParentheseClose(expressionLeft, expressionRight);
        } else {
            // Ну раз ничего из того, что выше(что является синтаксической ошибкой) то ошибку
            tarap("unexpected symbol " + lastItem);
            programEnd = failure;
            return 0;
        }
    }
    
    // Получить правый операнд
    private int getOperandRight(String[] expressionLeft, String[] expressionRight) {
        // Певрый элемент выражения справа
        String firstItem = expressionRight[0];
        
        // Первый элемент может быть числом?
        if (isNumeric(firstItem)) {
            // Возвратим число
            return Integer.parseInt(firstItem);
        } else 
        // Ну или если это переменная
        if (isVariableDeclared(firstItem)) {
            // Вернуть значение переменной
            return Integer.parseInt(getVariableValue(firstItem));
        } else
        // Ну или это скобка?
        if (firstItem.equals("(")) {
            // Тогда начать обработку выражения за скобкой
            expressionRight[0] = "";
            expressionRight = removeEmptyValuesFromTheArray(expressionRight);
            return processSeparatorParentheseOpen(expressionLeft, expressionRight);
        } else {
            // Ну раз ничего из того, что выше(что является синтаксической ошибкой) то ошибку
            tarap("unexpected symbol " + firstItem);
            programEnd = failure;
            return 0;
        }
    }
    
    // Обработка оператора - "="
    private boolean processOperatorEquals(String[] expressionLeft, String[] expressionRight) {
        // Объявить результат
        int resultOfExpression;
        
        // Уйти на обработку
        resultOfExpression = processExpression(expressionRight);
        
        // Первый элемент выражения - переменная?
        if (isVariableDeclared(expressionLeft[0])) {
            // У нас новая переменная, расскажем об этом
            tarap("variable new value '" + expressionLeft[0] + "': " + resultOfExpression);
            // Сохраним эту новую переменную
            setVariableValue(expressionLeft[0], Integer.toString(resultOfExpression));
        }
        
        // Вернуть положительное завершение
        return true;
    }
    
    // Обработка оператора - "+"
    private int processOperatorPlus(int firstOperand, int secondOperand) {
        // Вернуть результат
        return (firstOperand + secondOperand);
    }
    
    // Обработка оператора - "-"
    private int processOperatorMinus(int firstOperand, int secondOperand) {
        // Вернуть результат
        return (firstOperand - secondOperand);
    }
    
    // Обработка оператора - "/"
    private int processOperatorDivide(int firstOperand, int secondOperand) {
        // Вернуть результат
        return (firstOperand / secondOperand);
    }
    
    // Обработка оператора - "*"
    private int processOperatorMultiply(int firstOperand, int secondOperand) {
        // Вернуть результат
        return (firstOperand * secondOperand);
    }
    
    // Метод анализа выражений
    private int processExpression(String[] expression) {
        // Объявим результат
        int result = 0;
        
        // Если длина выражения не больше 2
        if (expression.length < 3) {
            // Первый элемент число?
            if (isNumeric(expression[0])) {
                // Тогда это число возвратим
                return Integer.parseInt(expression[0]);
            } else 
            // Первый элемент переменная?
            if (isVariableDeclared(expression[0])) {
                // Тогда значение этой переменной возвратим
                return Integer.parseInt(getVariableValue(expression[0]));
            } else 
            // Первый элемент не число и не переменная?
            {
                // Тогда ошибка
                tarap("syntax error");
                programEnd = failure;
            }
        }
        
        // Убрать лишние скобки вокруг всего выражения - начало
        expression = removeEmptyValuesFromTheArray(expression);
        for (int i = 0; i < expression.length / 2; i++) {
            // Новое выражение
            String[] newExpression = Arrays.copyOf(expression, expression.length);
            
            // Открывающей скобке пустое значение
            newExpression[0] = "";
            
            // Убрать пустые значения из выражения
            newExpression = removeEmptyValuesFromTheArray(newExpression);
            
            // Выяснить индекс закрывающей скобки
            int closeParentheseIndex = findClosingParenthese(newExpression);
            
            // Если индекс закрывающей скобки равен индекс последнего элемента
            if (closeParentheseIndex == (newExpression.length - 1)) {
                // Убрать первый и последний элементы из старого (основного) выражения - начало
                expression[0] = "";
                expression[expression.length - 1] = "";
                expression = removeEmptyValuesFromTheArray(expression);
                // Убрать первый и последний элементы из старого (основного) выражения - конец
            }
        }
        // Убрать лишние скобки вокруг всего выражения - конец
        
        // Продолжаем поиск? Да == 0, Нет == все остальные числа
        int continueSearchForOperator = 0;
        
        // Пройти по выражению с конца
        for (int i = expression.length - 1; i >= 0; i--) {
            // Если элемент выражения равен закрывающей скобке
            if (expression[i].equals(")")) {
                // Увеличиваем "Продолжаем поиск?"
                continueSearchForOperator++;
                continue;
            }
            // Если элемент выражения равен открывающей скобке
            if (expression[i].equals("(")) {
                // Уменьшаем "Продолжаем поиск?"
                continueSearchForOperator--;
                continue;
            }
            // Продолжаем поиск?
            // Если нет
            if (continueSearchForOperator <= 0) {
                // То проверяем является ли элемент оператором
                if (isOperator(expression[i])) {
                    // Левая часть от оператора
                    String[] expressionLeft = getLeftPart(expression, i);
                    
                    // Правая часть от оператора
                    String[] expressionRight = getRightPart(expression, i);
                    
                    // Сначала решить всё, что слева - начало
                    if (expressionLeft.length > 1) {
                        // Уйти на обработку
                        expressionLeft[0] = Integer.toString(processExpression(expressionLeft));
                    }
                    for (int inc = 1; inc < expressionLeft.length; inc++) {
                        expressionLeft[inc] = "";
                    }
                    expressionLeft = removeEmptyValuesFromTheArray(expressionLeft);
                    // Сначала решить всё, что слева - конец
                    
                    // Вернуть результат обработки
                    return processOperator(expression[i], expressionLeft, expressionRight);
                }
            }
        }

        // Вернуть результат
        return result;
    }
    
    // Обработать "("
    private int processSeparatorParentheseOpen(String[] expressionLeft, String[] expressionRight) {
        // Внутреннее выражение
        String[] innerExpression = new String[expressionRight.length];
        
        // Индекс закрывающей скобки в выражении
        int closingParentheseIndex = findClosingParenthese(expressionRight);
        
        // Если индекс отрицательный
        if (closingParentheseIndex == -1) {
            // Всё плохо
            programEnd = failure;
        }
        
        // Скопировать массив выражение во внутреннее выражение
        System.arraycopy(expressionRight, 0, innerExpression, 0, closingParentheseIndex);
        
        // Убрать пустые значения из массива внутреннего выражения
        innerExpression = removeEmptyValuesFromTheArray(innerExpression);
        
        // Обработать внутреннее выражение
        return processExpression(innerExpression);
    }
    
    // Обработать ")"
    private int processSeparatorParentheseClose(String[] expressionLeft, String[] expressionRight) {
        // Внутреннее выражение
        String[] innerExpression = new String[expressionLeft.length];
        
        // Индекс открывающей скобки внутри выражения
        int openingParentheseIndex = findOpeningParenthese(expressionLeft);
        
        // Если индекс -1
        if (openingParentheseIndex == -1) {
            // Всё плохо
            programEnd = failure;
        }
        
        // Выяснить внутреннее выражение
        for (int i = openingParentheseIndex; i < expressionLeft.length - openingParentheseIndex; i++) {
            innerExpression[i - openingParentheseIndex] = expressionLeft[i];
        }
        
        // Убрать скобку
        innerExpression[0] = "";
        
        // Убрать пустые значения
        innerExpression = removeEmptyValuesFromTheArray(innerExpression);
        
        // Обработать внутреннее выражение
        return processExpression(innerExpression);
    }
    
    // Метод для нахождения закрывающей скобки, соответствующей открывающей
    private int findClosingParenthese(String[] expression) {
        // Продолжаем искать? Нет = 0, Да = все остальные числа
        int continueSearch = 0;
        
        // Проходимся по выражению
        for (int i = 0; i < expression.length; i++) {
            // Если найдена ещё одна открывающая скобка
            if (expression[i].equals("(")) {
                // Увеличиваем значение "Продолжаем искать?"
                continueSearch++;
                continue;
            }
            // Если найдена закрывающая скобка
            if (expression[i].equals(")")) {
                // Проверяем "Продолжаем искать?"
                // Если ответ отрицательный
                if (continueSearch <= 0) {
                    // Возвращаем индекс закрывающей скобки
                    return i;
                }
                // Видимо ответ положительный, значит уменьшаем "Продолжаем искать?"
                continueSearch--;
            }
        }
        
        // Дошли до сюда? Значит скобки нет
        return -1;
    }
    
    // Метод для нахождения открывающей скобки, соответствующей закрывающей
    private int findOpeningParenthese(String[] expression) {
        // Продолжаем искать? Нет = 0, Да = все остальные числа
        int continueSearch = 0;
        
        // Проходимся по выражению
        for (int i = expression.length - 1; i >= 0; i--) {
            // Если найдена ещё одна закрывающая скобка
            if (expression[i].equals(")")) {
                // Увеличиваем значение "Продолжаем искать?"
                continueSearch++;
                continue;
            }
            // Если найдена открывающая скобка
            if (expression[i].equals("(")) {
                // Проверяем "Продолжаем искать?"
                // Если ответ отрицательный
                if (continueSearch <= 0) {
                    // Возвращаем индекс открывающей скобки
                    return i;
                }
                // Видимо ответ положительный, значит уменьшаем "Продолжаем искать?"
                continueSearch--;
            }
        }
        
        // Дошли до сюда? Значит скобки нет
        return -1;
    }
    
    // <editor-fold defaultstate="collapsed" desc="Разные методы, которые нужны, но хочется скрыть">

    // Метод быстрого добавления текста в поле справа
    // Добавление в поле справа использовалось часто, поэтому решил способ добавления ускорить
    // tarap("мама", 0) - textAreaResult.append("мама")
    private void tarap(String string, int newLine) {
        textAreaResult.append(string);
        if (newLine == 1) {
            textAreaResult.append("\n");
        }
    }
    
    // Ещё быстрее?
    private void tarap(String string) {
        tarap(string, 1);
    }
    
    // Определить, можно ли представить строку числом
    boolean isNumeric(String string) {
        try {
            // Если можно, то вернём положительный результат
            Integer.parseInt(string);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }

    // Убрать пустые значения из массива
    private String[] removeEmptyValuesFromTheArray(String[] array) {
        // Убрать пустые значения из массива строк
        return Arrays.stream(array).filter(value ->
                value != null && value.length() > 0
        )
        .toArray(size -> new String[size]);
    }
        
    // Убрать semicolon
    private String[] removeLastSemicolonFromArray(String[] array) {
        //Если последний элемент массива равен semicolon
        if (array[array.length - 1].equals(";")) {
            // Заменить значение последнего элемента массива на пустую строку
            array[array.length - 1] = "";
        }
        
        // Вернуть массив без пустых элементов
        return removeEmptyValuesFromTheArray(array);
    }
    
    // Метод взять всё, что слева массива @array относительно @index
    private String[] getLeftPart(String[] array, int index) {
        // Объявить результат
        String[] result = Arrays.copyOf(array, array.length);
        
        // Всему, что справа от индекса присвоить значение пустой строки
        for (int i = index; i < result.length; i++) {
            result[i] = "";
        }
        
        // Вернуть массив без пустых значений
        return removeEmptyValuesFromTheArray(result);
    }
    
    // Метод взять всё, что справа массива @array относительно @index
    private String[] getRightPart(String[] array, int index) {
        // Объявить результат
        String[] result = Arrays.copyOf(array, array.length);
        
        // Всему, что слева от индекса присвоить значение пустой строки
        for (int i = index; i > -1; i--) {
            result[i] = "";
        }
        
        // Вернуть массив без пустых значений
        return removeEmptyValuesFromTheArray(result);
    }
    
    // Метод, определаюящий есть ли у нас такая переменная
    private boolean isVariableDeclared(String variable) {
        // Пройти по массиву переменных
        for (String variableName : variables) {
            // Если совпадение найдено
            if (variableName.equals(variable)) {
                // Вернуть положительный результат
                return true;
            }
        }
        // Дошли до сюда? Значит переменной нет, возвращаем отрицательный результат
        return false;
    }
    
    // Метод для добавления в массив переменных новой переменной
    private boolean addToVariables(String variable) {
        // Проверить на наличие переменной с таким именем
        // Пройти по массиву переменных
        for (String variablesItem : variables) {
            // Если совпадение найдено
            if (variablesItem.equals(variable)) {
                // Вернуть отрицательный результат
                return false;
            }
        }
        
        // Массив с новыми переменными
        String[] newVariables = new String[variables.length + 1];
        // Скопировать значения из старого массива
        System.arraycopy(variables, 0, newVariables, 0, variables.length);
        
        // Массив с новыми значениями переменных
        String[] newVariablesValues = new String[variablesValues.length + 1];
        // Скопировать значения из старого массива
        System.arraycopy(variablesValues, 0, newVariablesValues, 0, variablesValues.length);
        
        // Добавить в новый массив новую переменную
        newVariables[newVariables.length - 1] = variable;
        // Дать ей новое значение "0"
        newVariablesValues[newVariablesValues.length - 1] = "0";
        // Обновить старый массив переменных новым массивом переменных
        variables = newVariables;
        // Обновить старый массив значений переменных новым массивом значений переменных
        variablesValues = newVariablesValues;
        
        // Вернуть положительный результат
        return true;
    }
    
    // Метод для изменения значения переменной
    private void setVariableValue(String variable, String value) {
        // Пройти по массиву переменных
        for (int i = 0; i < variables.length; i++) {
            // Если переменная найдена
            if (variables[i].equals(variable)) {
                // Установать соответствующее ей значение из массива значений переменных
                variablesValues[i] = value;
            }
        }
    }
    
    // Метод для получения значения переменной
    private String getVariableValue(String variable) {
        // Пройти по массиву переменных
        for (int i = 0; i < variables.length; i++) {
            // Если переменная найдена
            if (variables[i].equals(variable)) {
                // Вернуть соответствующее ей значение из массива значений переменных
                return variablesValues[i];
            }
        }
        // Если значение не нашлось, вернуть даже не число
        return "error";
    }
    
    //<editor-fold defaultstate="collapsed" desc="combineArrays [Не используется]">
    // Метод для объединения двух массивов в один
    private String[] combineArrays(String array1[], String array2[]) {
        String[] arrays = new String[array1.length + array2.length];
        
        int arraysIndex = 0;
        for (String array1Item : array1) {
            arrays[arraysIndex] = array1Item;
            arraysIndex++;
        }
        for (String array2Item : array2) {
            arrays[arraysIndex] = array2Item;
            arraysIndex++;
        }
        
        return arrays;
    }//</editor-fold>
    
    // Расширить массив @array на @sizeIncrease
    private String[] increaseSizeOfArray(String[] array, int sizeIncrease) {
        // Вернуть увеличенный на @sizeIncrease массив @array 
        return Arrays.copyOf(array, array.length + sizeIncrease);
    }
    
    // Проверить не является ли элемент строки (слово?) ключевым
    private boolean isKeyword(String word) {
        // Пройдёмся по массиву с определёнными ключевыми словами
        for (String keyword : keywords) {
            // Если найдено совпадение
            if (word.equals(keyword)) {
                // Вернуть положительный результат
                return true;
            }
        }
        // Дошли до сюда? Значит ключевое слово не нашлось в списке определённых ключевых слов,
        // поэтому возвращаем отрицательный результат
        return false;
    }
    
    // Проверить не является ли элемент строки (слово?) сепаратором
    private boolean isSeparator(String word) {
        // Пройдёмся по массиву с определёнными сепараторами
        for (String separator : separators) {
            // Если найдено совпадение
            if (word.equals(separator)) {
                // Вернуть положительный результат
                return true;
            }
        }
        // Дошли до сюда? Значит сепаратор не нашёлся в списке определённых сепараторов,
        // поэтому возвращаем отрицательный результат
        return false;
    }
    
    // Проверить не является ли элемент строки (слово?) оператором
    private boolean isOperator(String word) {
        // Пройдёмся по массиву с определёнными операторами
        for (String operator : operators) {
            // Если найдено совпадение
            if (word.equals(operator)) {
                // Вернуть положительный результат
                return true;
            }
        }
        // Дошли до сюда? Значит оператор не нашёлся в списке определённых операторов,
        // поэтому возвращаем отрицательный результат
        return false;
    }
    
    // Разделить массив сепараторми и операторами
    private String[] splitArrayWithSeparatorsAndOperators(String splittedLine[]) {
        // Разделим массив символами из @operators и @separators
        
        // Сначала символами из @separators
        splittedLine = splitArrayWithSeparators(splittedLine);
        // Теперь символами из @operators
        splittedLine = splitArrayWithOperators(splittedLine);
        
        // Вернём результат
        return splittedLine;
    }
    
    // Разделить массив сепараторами
    private String[] splitArrayWithSeparators(String splittedLine[]) {
        
        // Объявим результат
        String result[] = new String[splittedLine.length];
        
        // Собственно разделим массив символами из @separators
        int resultIndex = 0;
        // Пройдёмся по массиву
        for (int i = 0; i < splittedLine.length; i++) {
            // Разделим строку символами из @operators
            String[] splittedString = splitStringWithSeparators(splittedLine[i]);
            
            // Пройдёмся по этой строке, меняя возвращаемый массив
            for (int inc = 0; inc < splittedString.length; inc++) {
                result = increaseSizeOfArray(result, 1);
                result[resultIndex] = splittedString[inc];
                resultIndex++;
            }
        }
        
        // Уберём пустые элементы из массива и вернём результат
        return removeEmptyValuesFromTheArray(result);
    }
    
    // Разделить массив операторами
    private String[] splitArrayWithOperators(String splittedLine[]) {
        
        // Объявим результат
        String result[] = new String[splittedLine.length];
        
        // Собственно разделим массив символами из @operators
        int resultIndex = 0;
        // Пройдёмся по массиву
        for (int i = 0; i < splittedLine.length; i++) {
            // Разделим строку символами из @operators
            String[] splittedString = splitStringWithOperators(splittedLine[i]);
            
            // Пройдёмся по этой строке, меняя возвращаемый массив
            for (int inc = 0; inc < splittedString.length; inc++) {
                result = increaseSizeOfArray(result, 1);
                result[resultIndex] = splittedString[inc];
                resultIndex++;
            }
        }
        
        // Уберём пустые элементы из массива и вернём результат
        return removeEmptyValuesFromTheArray(result);
    }
    
    // Разделить слово сепараторами
    private String[] splitStringWithSeparators(String string) {
        // Вернуть массив, который сформирован из одного слова. Элементы в массиве разделены символами из @separators
        return splitStringWithDefinedSymbols(string, separators);
    }
    
    // Разделить слово операторами
    private String[] splitStringWithOperators(String string) {
        // Вернуть массив, который сформирован из одного слова. Элементы в массиве разделены символами из @operators
        return splitStringWithDefinedSymbols(string, operators);
    }
    
    // Разделить строку определёнными символами, передаваемыми в массиве @symbols
    private String[] splitStringWithDefinedSymbols(String string, String[] symbols) {
        
        // Объявим результат
        String result[] = new String[string.length() * 2];
        
        // Заполним массив пустыми строками
        for (int i = 0; i < result.length; i++) {
            result[i] = "";
        }
        
        // Уже и не помню что за цикл
        int lastIndex = 0;
        for (int i = 0; i < string.length(); i++) {
            boolean stop = true;
            for (int symbolsInc = 0; symbolsInc < symbols.length; symbolsInc++) {
                if (Character.toString(string.charAt(i)).equals(symbols[symbolsInc])) {
                    lastIndex++;
                    result[lastIndex] += string.charAt(i);
                    lastIndex++;
                    stop = false;
                    break;
                }
            }
            if (stop) {
                result[lastIndex] += string.charAt(i);
            }
        }
        
        // Уберём пустые элементы из массива
        result = removeEmptyValuesFromTheArray(result);
        
        // Вернём результат
        return result;
    }
    
    // Укоротить массив. Укорачивать, пока не встретиться что-нибудь из @words
    private String[] trimArrayWithDefinedWords(String strings[], String words[]) {
        
        // Пришло время остановить цикл?
        boolean timeToBreak = false;
        
        int i = 0;
        
        // Пройдёмся по массиву
        for (String string : strings) {
            for (String word : words) {
        
                // Искомое?
                if (string.equals(word)) {
                    // Тогда дадим установку на прекращение поиска
                    timeToBreak = true;
                    break;
                }
            }
            i++;
        
            // Если пришло время остановить цикл
            if (timeToBreak) {
                // Остановить
                break;
            }
        }
        
        // Заменим остальные значения пустыми значениями
        for (int inc = i; inc < strings.length; inc++) {
            strings[inc] = "";
        }
        
        // Уберём элементы с пустыми значениями из массива
        strings = removeEmptyValuesFromTheArray(strings);
        
        // Вернём укороченный массив
        return strings;
    }// </editor-fold>   
    
    private boolean updateResults() {
        
        // Сбросить значение состояния завершения анализа
        programEnd = success;
        
        // Опустошить массивы переменных - начало
        Arrays.fill(variables, "");
        Arrays.fill(variablesValues, "");
        variables = removeEmptyValuesFromTheArray(variables);
        variablesValues = removeEmptyValuesFromTheArray(variablesValues);
        // Опустошить массивы переменных - конец
        
        // Убрать подсветку
        textPaneSource.getHighlighter().removeAllHighlights();
        
        // Опустошить текст справа
        textAreaResult.setText("");

        // Нужна для подсветки (?)
        int textPaneSourceSymbolsIndexCounter = 0;
        
        // Начало разбора текста
        for (String line : textPaneSource.getText().split("\\n")) {
            
            // Нужна для подсветки (?)
            textPaneSourceSymbolsIndexCounter += line.length() + 1;
            // В случае если захочу реализовывать ошибки использовать:
            //paintLineToRed(line, textPaneSourceSymbolsIndexCounter - line.length() - 1);
            
            // Разделить строку на массив слов. Разделителем выступает " " (пробел)
            String splittedLine[] = line.split(" ");
            
            // Дополнительно разделить строку сепараторами
            splittedLine = splitArrayWithSeparatorsAndOperators(splittedLine);
            splittedLine = removeEmptyValuesFromTheArray(splittedLine);
            
            // Уберём из массива строки лишние символы - начало
            for (int i = 0; i < splittedLine.length; i++){
                // Символы на удаление - начало
                // ОСТОРОЖНО: ломаются при копировании
                // 
                //	
                //	
                // Символы на удаление - конец
                splittedLine[i] = splittedLine[i].replaceAll("[ 		]", "");
            }
            // Уберём из массива строки лишние символы - конец
            
            // Уберём пустые элементы из массива
            splittedLine = removeEmptyValuesFromTheArray(splittedLine);
            
            // Уберём semicolon (?)
            String[] words = {";"};
            splittedLine = trimArrayWithDefinedWords(splittedLine, words);
            
            // Обработка первого слова строки - начало
            boolean isLiteral = true;
            for (int i = 0; i < splittedLine.length; i++) {
                // Если слово равно одному из ключевых слов
                if (isKeyword(splittedLine[i])) {
                    // обработать как ключевое слово
                    processKeyword(splittedLine[i], splittedLine);
                    isLiteral = false;
                    break;
                }
            }
            // Если это литерал
            if (isLiteral) {
                // Обработать как литерал
                if (!processLiteral(splittedLine[0], splittedLine)) {
                    tarap("invalid syntax");
                    return false;
                }
            }
            // Обработка первого слова строки - конец

        }
        // Выведем какие у нас есть переменные и их значения
//        tarap("");
//        tarap("// variables and their final values");
//        tarap("// " + Arrays.toString(variables));
//        tarap("// " + Arrays.toString(variablesValues));
        return true;
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(PascalAnalyserGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(PascalAnalyserGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(PascalAnalyserGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(PascalAnalyserGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new PascalAnalyserGUI().setVisible(true);
            }
        });
    }
    
    // <editor-fold defaultstate="collapsed" desc="Переменные от NetBeans">
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JLabel labelResult;
    private javax.swing.JLabel labelSource;
    private javax.swing.JPanel panelMain;
    private javax.swing.JPanel panelResult;
    private javax.swing.JPanel panelResultLabel;
    private javax.swing.JPanel panelResultTextArea;
    private javax.swing.JPanel panelSource;
    private javax.swing.JPanel panelSourceLabel;
    private javax.swing.JPanel panelSourceText;
    private javax.swing.JTextArea textAreaResult;
    private javax.swing.JTextPane textPaneSource;
    // End of variables declaration//GEN-END:variables
    // </editor-fold>
    
}
